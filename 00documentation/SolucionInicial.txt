Nuestra solución pensada era la siguiente:

Memoria Compartida General (Todos los Emisor y los Receptor):
- Indice de .txt por Encriptar (Por cual letra va la encriptación)
- Queue de posiciones disponibles de la memoria compartida para introducir el índice actual encriptado, inicialmente disponible según las posiciones establecidas en el Inicializador (El emisor aplica dequeue y el Receptor aplica queue).
- Queue de posiciones disponibles de la memoria compartida para desencriptar el valor, incialmente vacia (El emisor aplica enqueue cuando introduce un valor recién encriptado y el receptor aplica un dequeue para que el Emisor pueda utilizar el espacio de memoria disponible para algun valor)
- El valor de queue de pos disponibles de encriptacion, simplemente contiene la direccion de memoria compartida disponible, mientras que el valor del queue de desencriptación contiene la direccion de memoria compartida utilizada y el indice de texto.
- Aparte necesitamos un struct por cada valor de la memoria compartida, en donde tendremos que contener el ascii, el indice de introduccion segun los espacion de memoria disponibles, y hora de introduccion.

Logica de aplicacion:
1. Iniciamos con el QueueEncript con los valores establecidos desde el incializador, y el QueueDeencript vacio. El QueueEncript contendra los punteros de los structs de cada caracter, hora introducido e indice (Nulos incialmente).
2. Despues algún Encript, el mas rapido, tomara el indice actual, lo considera como el que analizara y luego le suma 1 al indice, y despues aplicará un dequeue de QueueEncript (de forma atomica). Durante esto se deberan de bloquear otros Ecripts si es que otros estaban buscando el indice de .txt actual. Luego el struct del Encript que esta trabajando con el indice obtenido, no deberia de ser necesario protegerlo, porque solo un Encript podra estarlo modificando. Entonces el Encript lo modifica enciptando el ascii del indice, identifica el indice segun el puntero del dequeue y cuando se modifique el ascii entonces tambien la hora. Y luego entonces se le aplica un enqueue al QueueDeencript de este valor, donde este contendra el puntero de memoria compartida y el indice de texto contenido.
3. Entonces el Deencript, el mas rapido, tomara el QueueDeencript y le aplicara un dequeue (atomico) y asi que el mas rapido tome el indice de texto y el ascii actual, le aplica la desencriptacion. Cuando se despeja el puntero de memoria utilizado, entonces se le regresa al QueueEncript, como valor disponible por modificar. Tambien el deencript tiene que hacer prints cada cuando lee un valor de su QueueDeencript, segun el valor, el indice del puncture, y la hora de lectura.
4. Finalmente el Finalizador va finalizando los procesos y recolectando los valores estadisticos de cada proceso y luego los muestra todos. Y asi es como se aplica este sistema.
5. Considerar que los estados de bloqueado del Encript es cuando el indice esta siendo utilizado por otro proceso, o cuando el QueueEncript esta vacio! Y los estados de bloqueado del Deencript es cuando el QueueDeencript esta vacio. Y ESTOS TIENEN QUE SER UN ESTADO DE BLOQUEADO INTELIGENTE Y NO IMPLEMENTAR BUSY WAITING!
6. Tendremos .bin como entrada de valores ASCII y un .bin de salida de valores ASCII. Por ende, el proceso de Incializador recibe el .txt y genera el .bin como memoria compartida de los Emisores y un .bin vacio para la memoria compartida de los Receptores. Y finalmente el Finalizador toma el .bin de los receptores y genera un .txt con estos valores para mayor claridad. Y como ultimo detalle considera que la secuencialidad de respuesta final igual a la respuesta inicial es una garantía necesaria!